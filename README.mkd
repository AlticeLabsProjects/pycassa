pycasso
=======

pycasso is a Cassandra library with the following features:

1. Auto-failover single or thread-local connections
2. A simplified version of the thrift interface
3. A method to map an existing class to a Cassandra ColumnFamily.
4. Support for SuperColumns

Requirements
------------

    thrift: http://incubator.apache.org/thrift/
    Cassandra: http://incubator.apache.org/cassandra/

Install thrift with the python bindings.

Cassandra was only tested with version 0.5.0-beta2, but should work with some previous versions.

It comes with the Cassandra python files for convenience, but you can replace them with your own.

Basic Usage
-----------

All functions are documented with docstrings.
To read usage documentation:

    >>> import pycasso
    >>> help(pycasso.ColumnFamily.get)

For a single connection (which is _not_ thread-safe), pass a list of servers:

    >>> client = pycasso.connect() # Defaults to connecting to the server at 'localhost:9160'
    >>> client = pycasso.connect(['localhost:9160'])

Thread-local connections opens a connection for every thread that calls a Cassandra function. It also automatically balances the number of connections between servers, unless round_robin=False.

    >>> client = pycasso.connect_thread_local() # Defaults to connecting to the server at 'localhost:9160'
    >>> client = pycasso.connect_thread_local(['localhost:9160', 'other_server:9160']) # Round robin connections
    >>> client = pycasso.connect_thread_local(['localhost:9160', 'other_server:9160'], round_robin=False) # Connect in list order

Connections are robust to server failures. Upon a disconnection, it will attempt to connect to each server in the list in turn. If no server is available, it will raise a NoServerAvailable exception.

To use the standard interface, create a ColumnFamily instance.

    >>> cf = pycasso.ColumnFamily(client, 'Test Keyspace', 'Test ColumnFamily')

The value returned by an insert is the timestamp used for insertion, or int(time.mktime(time.gmtime())). You may replace this function with your own (see Extra Documentation).

    >>> cf.insert('foo', {'column1': 'val1'})
    1261349837
    >>> cf.get('foo')
    {'column1': 'val1'}

Insert also acts to update values.

    >>> cf.insert('foo', {'column1': 'val2'})
    1261349910
    >>> cf.get('foo')
    {'column1': 'val2'}

You may insert multiple columns at once.

    >>> cf.insert('bar', {'column1': 'val3', 'column2': 'val4'})
    1261350013
    >>> cf.multiget(['foo', 'bar'])
    {'foo': {'column1': 'val2'}, 'bar': {'column1': 'val3', 'column2': 'val4'}}
    >>> cf.get_count('bar')
    2

get_range() returns an iterable. Call it with list() to convert it to a list.

    >>> list(cf.get_range())
    [('bar', {'column1': 'val3', 'column2': 'val4'}), ('foo', {'column1': 'val2'})]
    >>> list(cf.get_range(row_count=1))
    [('bar', {'column1': 'val3', 'column2': 'val4'})]

You can remove entire keys or just a certain column.

    >>> cf.remove('bar', column='column1')
    1261350220
    >>> cf.get('bar')
    {'column2': 'val4'}
    >>> cf.remove('bar')
    1261350226
    >>> cf.get('bar')
    Traceback (most recent call last):
    ...
    pycasso.cassandra.ttypes.NotFoundException: NotFoundException()

Class Mapping
-------------

You can also map existing classes using ColumnFamilyMap.

    >>> class Test(object):
    ...     pass
    ...

Map a class to a ColumnFamily. This will naively insert all attributes on insert() and get all columns on get().

    >>> TestMap = pycasso.ColumnFamilyMap(Test, cf)

However, it's often preferable to supply the columns argument. columns is a dictionary mapping columns to their default value. If, for example, there is a schema change, but some old records in the Cassandra database don't have certain columns, fetching them will fill in their default value. The columns argument also indicates what attributes are saved when you call insert(). All other attributes are ignored.

    >>> TestMap = pycasso.ColumnFamilyMap(Test, cf, columns={'col1': 'default1', 'col2': 'default2'})

All the functions are exactly the same, except that they return instances of the supplied class when possible.

    >>> t = Test()
    >>> t.col1 = '1'
    >>> t.col2 = '2'
    >>> t.key = 'maptest'
    >>> TestMap.insert(t)
    1261395497
    >>> TestMap.get(t.key).key
    'maptest'
    >>> TestMap.get(t.key).col1
    '1'
    >>> TestMap.multiget([t.key])
    {'maptest': <__main__.Test object at 0x7fac9c85e990>}
    >>> list(TestMap.get_range())
    [<__main__.Test object at 0x7fac9c85ea90>]
    >>> TestMap.get_count(t.key)
    2
    >>> TestMap.remove(t)
    1261395603
    >>> TestMap.get(t.key)
    Traceback (most recent call last):
    ...
    pycasso.cassandra.ttypes.NotFoundException: NotFoundException()

SuperColumns
------------

To use SuperColumns, first pass super=True to the ColumnFamily constructor.

    >>> cf = pycasso.ColumnFamily(client, 'Test Keyspace', 'Test SuperColumnFamily', super=True)
    >>> cf.insert('key1', {'1': {'sub1': 'val1', 'sub2': 'val2'}, '2': {'sub3': 'val3', 'sub4': 'val4'}})
    1261490144
    >>> cf.get('key1')
    {'1': {'sub2': 'val2', 'sub1': 'val1'}, '2': {'sub4': 'val4', 'sub3': 'val3'}}
    >>> cf.remove('key1', '1')
    1261490176
    >>> cf.get('key1')
    {'2': {'sub4': 'val4', 'sub3': 'val3'}}
    >>> cf.get('key1', super_column='2')
    {'sub3': 'val3', 'sub4': 'val4'}
    >>> cf.multiget(['key1'], super_column='2')
    {'key1': {'sub3': 'val3', 'sub4': 'val4'}}
    >>> list(cf.get_range(super_column='2'))
    [('key1', {'2': {'sub3': 'val3', 'sub4': 'val4'}})]

These output values retain the same format as given by the Cassandra thrift interface.

Advanced
--------

pycasso currently returns Cassandra Columns and SubColumns as python dictionaries. Sometimes, though, you care about the order of elements. If you have access to an ordered dictionary class (such as collections.OrderedDict in python 2.7), then you may pass it to the constructor. All returned values will be of that class.

    >>> cf = pycasso.ColumnFamily(client, 'Test Keyspace', 'Test ColumnFamily',
                                  row_class=collections.OrderedDict)
    >>> cf = pycasso.ColumnFamily(client, 'Test Keyspace', 'Test SuperColumnFamily',
                                  row_class=collections.OrderedDict,
                                  column_class=collections.OrderedDict,
                                  super=True)

Extra Documentation
-------------------

All the functions have the exact same functionality as their thrift counterparts, but it may be hidden as keyword arguments.

    ColumnFamily.__init__()
        Parameters
        ----------
        client   : cassandra.Cassandra.Client
            Cassandra client with thrift API
        keyspace : str
            The Keyspace this ColumnFamily belongs to
        column_family : str
            The name of this ColumnFamily
        buffer_size : int
            When calling get_range(), the intermediate results need to be
            buffered if we are fetching many rows, otherwise the Cassandra
            server will overallocate memory and fail.  This is the size of
            that buffer.
        read_consistency_level : ConsistencyLevel
            Affects the guaranteed replication factor before returning from
            any read operation
        write_consistency_level : ConsistencyLevel
            Affects the guaranteed replication factor before returning from
            any write operation
        timestamp : function
            The default timestamp function returns:
            int(time.mktime(time.gmtime()))
            Or the number of seconds since Unix epoch in GMT.
            Set timestamp to replace the default timestamp function with your
            own.
        super : bool
            Whether this ColumnFamily has SuperColumns
        row_class : class (must act like the dict type)
            The default row_class is dict.
            If the order of columns matter to you, pass your own dictionary
            class, or python 2.7's new collections.OrderedDict. All returned
            rows are instances of this.
        column_class : class (must act like the dict type)
            Only applies to SuperColumns.

            The default column_class is dict.
            If the order of subcolumns matter to you, pass your own dictionary
            class, or python 2.7's new collections.OrderedDict. All returned
            columns are instances of this.

    ColumnFamily.get()
        Parameters
        ----------
        key : str
            The key to fetch
        columns : [str]
            Limit the columns fetched to the specified list
        column_start : str
            Only fetch when a column is >= column_start
        column_finish : str
            Only fetch when a column is <= column_finish
        column_reversed : bool
            Fetch the columns in reverse order. This will do nothing unless
            you passed a row_class or column_class to the constructor.
        column_count : int
            Limit the number of columns fetched per key
        include_timestamp : bool
            If true, return a (value, timestamp) tuple for each column
        super_column : str
            Return columns only in this super_column

    ColumnFamily.multiget()
        Parameters
        ----------
        keys : [str]
            A list of keys to fetch
        columns : [str]
            Limit the columns fetched to the specified list
        column_start : str
            Only fetch when a column is >= column_start
        column_finish : str
            Only fetch when a column is <= column_finish
        column_reversed : bool
            Fetch the columns in reverse order. This will do nothing unless
            you passed a row_class or column_class to the constructor.
        column_count : int
            Limit the number of columns fetched per key
        include_timestamp : bool
            If true, return a (value, timestamp) tuple for each column
        super_column : str
            Return columns only in this super_column

    ColumnFamily.get_count()
        Parameters
        ----------
        key : str
            The key with which to count columns
        super_column : str
            Count the columns only in this super_column

    ColumnFamily.get_range()
        Parameters
        ----------
        start : str
            Start from this key (inclusive)
        finish : str
            End at this key (inclusive)
        columns : [str]
            Limit the columns fetched to the specified list
        column_start : str
            Only fetch when a column is >= column_start
        column_finish : str
            Only fetch when a column is <= column_finish
        column_reversed : bool
            Fetch the columns in reverse order. This will do nothing unless
            you passed a row_class or column_class to the constructor.
        column_count : int
            Limit the number of columns fetched per key
        row_count : int
            Limit the number of rows fetched
        include_timestamp : bool
            If true, return a (value, timestamp) tuple for each column
        super_column : string
            Return columns only in this super_column

    ColumnFamily.insert()
        Parameters
        ----------
        key : str
            The key to insert or update the columns at
        columns : {'column': 'value'}
            Column: {'column': 'value'}
            SuperColumn: {'column': {'subcolumn': 'value'}}
            The columns or supercolumns to insert or update


    ColumnFamily.remove()
        Parameters
        ----------
        key : str
            The key to remove. If column is not set, remove all columns
        column : str
            If set, remove only this column or supercolumn
