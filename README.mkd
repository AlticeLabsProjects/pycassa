# Note

If you are using the 0.6.x series of Cassandra then get pycassa 0.3 from the
Downloads section and read the documentation contained within.  This README
applies to the current state of pycassa which tracks Cassandra's development
(work in-progress toward Cassandra 0.7).

pycassa
=======

pycassa is a python client library for Apache Cassandra with the following features:

1. Auto-failover single or thread-local connections
2. Connection pooling
3. A batch interface
4. Simplified version of the Thrift interface
5. A method to map an existing class to a Cassandra column family

Documentation
-------------

While this README includes a lot of information, the official and more
thorough documentation can be found here:

[http://pycassa.github.com/pycassa/](http://pycassa.github.com/pycassa/)

Getting Help
------------

IRC:
 - Use channel #cassandra on irc.freenode.net. If you don't have an IRC client,
   you can use [freenode's web based client](http://webchat.freenode.net/?channels=#cassandra).

Mailing List:
 - User list: [http://groups.google.com/group/pycassa-discuss](http://groups.google.com/group/pycassa-discuss)
 - Developer list: [http://groups.google.com/group/pycassa-devel](http://groups.google.com/group/pycassa-devel)

Requirements
------------

    thrift: http://incubator.apache.org/thrift/
    Cassandra: http://cassandra.apache.org

To install thrift's python bindings:

    easy_install thrift05

Installation
------------

If easy_install is available, you can use:

    easy_install pycassa

The simplest way to install manually is to copy the pycassa directories to
your program.  If you want to install, run setup.py as a superuser.

    python setup.py install

Connecting
----------

All functions are documented with docstrings.  To read usage documentation,
you can use help:

    >>> import pycassa
    >>> help(pycassa.ColumnFamily.get)

To get a connection pool, pass a Keyspace and an optional list of servers:

    >>> pool = pycassa.connect('Keyspace1') # Defaults to connecting to the server at 'localhost:9160'
    >>> pool = pycassa.connect('Keyspace1', ['192.168.2.10:9160'])

See the [tutorial](http://pycassa.github.com/pycassa/tutorial.html#making-a-connection) for more details.

Basic Usage
-----------

To use the standard interface, create a ColumnFamily instance.

    >>> pool = pycassa.connect('Keyspace1')
    >>> cf = pycassa.ColumnFamily(pool, 'Standard1')

The value returned by insert() is the timestamp used for insertion, or int(time.time() * 1e6), by default.

    >>> cf.insert('foo', {'column1': 'val1'})
    1261349837816957
    >>> cf.get('foo')
    {'column1': 'val1'}

insert() also acts to update values:

    >>> cf.insert('foo', {'column1': 'val2'})
    1261349910511572
    >>> cf.get('foo')
    {'column1': 'val2'}

You may insert multiple columns at once:

    >>> cf.insert('bar', {'column1': 'val3', 'column2': 'val4'})
    1261350013606860
    >>> cf.multiget(['foo', 'bar'])
    {'foo': {'column1': 'val2'}, 'bar': {'column1': 'val3', 'column2': 'val4'}}
    >>> cf.get_count('bar')
    2

get_range() returns an iterable. Call it with list() to convert it to a list.

    >>> list(cf.get_range())
    [('bar', {'column1': 'val3', 'column2': 'val4'}), ('foo', {'column1': 'val2'})]
    >>> list(cf.get_range(row_count=1))
    [('bar', {'column1': 'val3', 'column2': 'val4'})]

You can remove entire keys or just a certain column.

    >>> cf.remove('bar', columns=['column1'])
    1261350220106863
    >>> cf.get('bar')
    {'column2': 'val4'}
    >>> cf.remove('bar')
    1261350226926859
    >>> cf.get('bar')
    Traceback (most recent call last):
    ...
    cassandra.ttypes.NotFoundException: NotFoundException()

Class Mapping
-------------

You can also map existing classes using ColumnFamilyMap.

    >>> class Test(object):
    ...     string_column       = pycassa.String(default='Your Default')
    ...     int_str_column      = pycassa.IntString(default=5)
    ...     float_str_column    = pycassa.FloatString(default=8.0)
    ...     float_column        = pycassa.Float64(default=0.0)
    ...     datetime_str_column = pycassa.DateTimeString() # default=None

The defaults will be filled in whenever you retrieve instances from the
Cassandra server and the column doesn't exist. If, for example, you add columns
in the future, you simply add the relevant column and the default will be there
when you get old instances.

IntString, FloatString, and DateTimeString all use string representations for
storage. Float64 is stored as a double and is native-endian. Be aware of any
endian issues if you use it on different architectures, or perhaps make your
own column type.

When creating a ColumnFamily object for use with a ColumnFamilyMap, it's
important to disable autopacking in the ColumnFamily by setting
autopack_names=False and autopack_values=False in the constructor.

    >>> cf = pycassa.ColumnFamily(pool, 'Standard1',
    ...                           autopack_names=False, autopack_values=False)
    >>> Test.objects = pycassa.ColumnFamilyMap(Test, cf)

All the functions are exactly the same, except that they return instances of the
supplied class when possible.

    >>> t = Test()
    >>> t.key = 'maptest'
    >>> t.string_column = 'string test'
    >>> t.int_str_column = 18
    >>> t.float_column = t.float_str_column = 35.8
    >>> from datetime import datetime
    >>> t.datetime_str_column = datetime.now()
    >>> Test.objects.insert(t)
    1261395560186855

    >>> Test.objects.get(t.key).string_column
    'string test'
    >>> Test.objects.get(t.key).int_str_column
    18
    >>> Test.objects.get(t.key).float_column
    35.799999999999997
    >>> Test.objects.get(t.key).datetime_str_column
    datetime.datetime(2009, 12, 23, 17, 6, 3)

    >>> Test.objects.multiget([t.key])
    {'maptest': <__main__.Test object at 0x7f8ddde0b9d0>}
    >>> list(Test.objects.get_range())
    [<__main__.Test object at 0x7f8ddde0b710>]
    >>> Test.objects.get_count(t.key)
    7

    >>> Test.objects.remove(t)
    1261395603906864
    >>> Test.objects.get(t.key)
    Traceback (most recent call last):
    ...
    cassandra.ttypes.NotFoundException: NotFoundException()

Super Columns
-------------

ColumnFamilies that deal with super column familes
are created exactly the same way that they are for standard
column families.  When using them, just include an extra layer
in the column dictionaries.

    >>> cf = pycassa.ColumnFamily(client, 'Test SuperColumnFamily')
    >>> cf.insert('key1', {'1': {'sub1': 'val1', 'sub2': 'val2'}, '2': {'sub3': 'val3', 'sub4': 'val4'}})
    1261490144457132
    >>> cf.get('key1')
    {'1': {'sub2': 'val2', 'sub1': 'val1'}, '2': {'sub4': 'val4', 'sub3': 'val3'}}
    >>> cf.remove('key1', super_column='1')
    1261490176976864
    >>> cf.get('key1')
    {'2': {'sub4': 'val4', 'sub3': 'val3'}}
    >>> cf.get('key1', super_column='2')
    {'sub3': 'val3', 'sub4': 'val4'}
    >>> cf.multiget(['key1'], super_column='2')
    {'key1': {'sub3': 'val3', 'sub4': 'val4'}}
    >>> list(cf.get_range(super_column='2'))
    [('key1', {'sub3': 'val3', 'sub4': 'val4'})]

You may also use a ColumnFamilyMap with super columns:

    >>> Test.objects = pycassa.ColumnFamilyMap(Test, cf)
    >>> t = Test()
    >>> t.key = 'key1'
    >>> t.super_column = 'super1'
    >>> t.string_column = 'foobar'
    >>> t.int_str_column = 5
    >>> t.float_column = t.float_str_column = 35.8
    >>> t.datetime_str_column = datetime.now()
    >>> Test.objects.insert(t)
    >>> Test.objects.get(t.key)
    {'super1': <__main__.Test object at 0x20ab350>}
    >>> Test.objects.multiget([t.key])
    {'key1': {'super1': <__main__.Test object at 0x20ab550>}}

Batch Mutations
---------------

The batch interface allows insert/update/remove operations to be performed in
batches. This allows a convenient mechanism for streaming updates or doing a
large number of operations while reducing number of RPC roundtrips.

Batch mutator objects are synchronized and can be safely passed around threads.

    >>> b = cf.batch(queue_size=10)
    >>> b.insert('key1', {'col1':'value11', 'col2':'value21'})
    >>> b.insert('key2', {'col1':'value12', 'col2':'value22'}, ttl=15)
    >>> b.remove('key1', ['col2'])
    >>> b.remove('key2')
    >>> b.send()

One can use the `queue_size` argument to control how many mutations will be
queued before an automatic `send` is performed. This allows simple streaming of
updates. If set to `None`, automatic checkpoints are disabled. Default is 100.

Supercolumns are supported:

    >>> b = scf.batch()
    >>> b.insert('key1', {'supercol1': {'colA':'value1a', 'colB':'value1b'}
                         {'supercol2': {'colA':'value2a', 'colB':'value2b'}})
    >>> b.remove('key1', ['colA'], 'supercol1')
    >>> b.send()

You may also create a batch mutator from a client instance, allowing operations
on multiple column families:

    >>> b = Mutator(pool)
    >>> b.insert(cf, 'key1', {'col1':'value1', 'col2':'value2'})
    >>> b.insert(supercf, 'key1', {'subkey1': {'col1':'value1', 'col2':'value2'}})
    >>> b.send()

Note: This interface does not implement atomic operations across column
      families. All the limitations of the `batch_mutate` Thrift API call
      applies. Remember, a mutation in Cassandra is always atomic per key per
      column family only.

Note: If a single operation in a batch fails, the whole batch fails.

In Python >= 2.5, mutators can be used as context managers, where an implicit
`send` will be called upon exit.

    >>> with cf.batch() as b:
    >>>     b.insert('key1', {'col1':'value11', 'col2':'value21'})
    >>>     b.insert('key2', {'col1':'value12', 'col2':'value22'})

Calls to `insert` and `remove` can also be chained:

    >>> cf.batch().remove('foo').remove('bar').send()

Connection Pooling
------------------

See the [tutorial](http://pycassa.github.com/pycassa/tutorial.html#connection-pooling) and
[pool section](http://pycassa.github.com/pycassa/api/pycassa/pool.html) of the API for
more details on connection pooling.

Advanced
--------

pycassa currently returns Cassandra columns and super columns as OrderedDicts
to preserve column and row order. Other dictionaries, such as 'dict' may be
used instead. All returned values will be of that class.

    >>> cf = pycassa.ColumnFamily(pool, 'Standard1', dict_class=dict)

You may also define your own Column types for the mapper. For example, the IntString may be defined as:

    >>> class IntString(pycassa.Column):
    ...     def pack(self, val):
    ...         return str(val)
    ...     def unpack(self, val):
    ...         return int(val)
    ... 
